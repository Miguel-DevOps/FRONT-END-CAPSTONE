{"ast":null,"code":"import { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nconst types = {\n  decay,\n  keyframes: keyframes,\n  tween: keyframes,\n  spring\n};\nfunction loopElapsed(elapsed, duration, delay = 0) {\n  return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration = 0, delay = 0, isForwardPlayback = true) {\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = update => {\n  const passTimestamp = ({\n    delta\n  }) => update(delta);\n  return {\n    start: () => sync.update(passTimestamp, true),\n    stop: () => cancelSync.update(passTimestamp)\n  };\n};\nfunction animate({\n  duration,\n  driver = framesync,\n  elapsed = 0,\n  repeat: repeatMax = 0,\n  repeatType = \"loop\",\n  repeatDelay = 0,\n  keyframes: keyframes$1,\n  autoplay = true,\n  onPlay,\n  onStop,\n  onComplete,\n  onRepeat,\n  onUpdate,\n  type = \"keyframes\",\n  ...options\n}) {\n  var _a, _b;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n  const origin = keyframes$1[0];\n  const target = keyframes$1[keyframes$1.length - 1];\n  if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\n    interpolateFromNumber = interpolate([0, 100], [origin, target], {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  const animation = animator({\n    ...options,\n    duration,\n    keyframes: keyframes$1\n  });\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber) latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate && onUpdate(latest);\n    if (isComplete) {\n      if (repeatCount === 0) {\n        computedDuration = computedDuration !== undefined ? computedDuration : elapsed;\n      }\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay && onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop && onStop();\n      driverControls.stop();\n    },\n    sample: t => {\n      return animation.next(Math.max(0, t));\n    }\n  };\n}\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };","map":{"version":3,"names":["keyframes","spring","decay","sync","cancelSync","interpolate","types","tween","loopElapsed","elapsed","duration","delay","reverseElapsed","isForwardPlayback","hasRepeatDelayElapsed","framesync","update","passTimestamp","delta","start","stop","animate","driver","repeat","repeatMax","repeatType","repeatDelay","keyframes$1","autoplay","onPlay","onStop","onComplete","onRepeat","onUpdate","type","options","_a","_b","driverControls","repeatCount","computedDuration","latest","isComplete","interpolateFromNumber","animator","length","origin","target","needsInterpolation","call","clamp","animation","flipTarget","complete","state","next","Math","max","value","done","undefined","play","sample","t"],"sources":["C:/Users/User/Desktop/Front End Developer/PORTFOLIO PROJECT/FRONT-END CAPSTONE/node_modules/framer-motion/dist/es/animation/legacy-popmotion/index.mjs"],"sourcesContent":["import { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\n\nconst types = {\n    decay,\n    keyframes: keyframes,\n    tween: keyframes,\n    spring,\n};\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration = 0, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync.update(passTimestamp, true),\n        stop: () => cancelSync.update(passTimestamp),\n    };\n};\nfunction animate({ duration, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, keyframes: keyframes$1, autoplay = true, onPlay, onStop, onComplete, onRepeat, onUpdate, type = \"keyframes\", ...options }) {\n    var _a, _b;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n    const origin = keyframes$1[0];\n    const target = keyframes$1[keyframes$1.length - 1];\n    if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\n        interpolateFromNumber = interpolate([0, 100], [origin, target], {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const animation = animator({\n        ...options,\n        duration,\n        keyframes: keyframes$1,\n    });\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber)\n                latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate && onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0) {\n                computedDuration =\n                    computedDuration !== undefined ? computedDuration : elapsed;\n            }\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay && onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop && onStop();\n            driverControls.stop();\n        },\n        sample: (t) => {\n            return animation.next(Math.max(0, t));\n        },\n    };\n}\n\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,MAAM,QAAQ,cAAc;AACrC,SAASC,KAAK,QAAQ,aAAa;AACnC,SAASC,IAAI,EAAEC,UAAU,QAAQ,2BAA2B;AAC5D,SAASC,WAAW,QAAQ,6BAA6B;AAEzD,MAAMC,KAAK,GAAG;EACVJ,KAAK;EACLF,SAAS,EAAEA,SAAS;EACpBO,KAAK,EAAEP,SAAS;EAChBC;AACJ,CAAC;AACD,SAASO,WAAWA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,KAAK,GAAG,CAAC,EAAE;EAC/C,OAAOF,OAAO,GAAGC,QAAQ,GAAGC,KAAK;AACrC;AACA,SAASC,cAAcA,CAACH,OAAO,EAAEC,QAAQ,GAAG,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEE,iBAAiB,GAAG,IAAI,EAAE;EAChF,OAAOA,iBAAiB,GAClBL,WAAW,CAACE,QAAQ,GAAG,CAACD,OAAO,EAAEC,QAAQ,EAAEC,KAAK,CAAC,GACjDD,QAAQ,IAAID,OAAO,GAAGC,QAAQ,CAAC,GAAGC,KAAK;AACjD;AACA,SAASG,qBAAqBA,CAACL,OAAO,EAAEC,QAAQ,EAAEC,KAAK,EAAEE,iBAAiB,EAAE;EACxE,OAAOA,iBAAiB,GAAGJ,OAAO,IAAIC,QAAQ,GAAGC,KAAK,GAAGF,OAAO,IAAI,CAACE,KAAK;AAC9E;AACA,MAAMI,SAAS,GAAIC,MAAM,IAAK;EAC1B,MAAMC,aAAa,GAAGA,CAAC;IAAEC;EAAM,CAAC,KAAKF,MAAM,CAACE,KAAK,CAAC;EAClD,OAAO;IACHC,KAAK,EAAEA,CAAA,KAAMhB,IAAI,CAACa,MAAM,CAACC,aAAa,EAAE,IAAI,CAAC;IAC7CG,IAAI,EAAEA,CAAA,KAAMhB,UAAU,CAACY,MAAM,CAACC,aAAa;EAC/C,CAAC;AACL,CAAC;AACD,SAASI,OAAOA,CAAC;EAAEX,QAAQ;EAAEY,MAAM,GAAGP,SAAS;EAAEN,OAAO,GAAG,CAAC;EAAEc,MAAM,EAAEC,SAAS,GAAG,CAAC;EAAEC,UAAU,GAAG,MAAM;EAAEC,WAAW,GAAG,CAAC;EAAE1B,SAAS,EAAE2B,WAAW;EAAEC,QAAQ,GAAG,IAAI;EAAEC,MAAM;EAAEC,MAAM;EAAEC,UAAU;EAAEC,QAAQ;EAAEC,QAAQ;EAAEC,IAAI,GAAG,WAAW;EAAE,GAAGC;AAAQ,CAAC,EAAE;EAClP,IAAIC,EAAE,EAAEC,EAAE;EACV,IAAIC,cAAc;EAClB,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,gBAAgB,GAAG9B,QAAQ;EAC/B,IAAI+B,MAAM;EACV,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAI7B,iBAAiB,GAAG,IAAI;EAC5B,IAAI8B,qBAAqB;EACzB,MAAMC,QAAQ,GAAGtC,KAAK,CAACqB,WAAW,CAACkB,MAAM,GAAG,CAAC,GAAG,WAAW,GAAGX,IAAI,CAAC,IAAIlC,SAAS;EAChF,MAAM8C,MAAM,GAAGnB,WAAW,CAAC,CAAC,CAAC;EAC7B,MAAMoB,MAAM,GAAGpB,WAAW,CAACA,WAAW,CAACkB,MAAM,GAAG,CAAC,CAAC;EAClD,IAAI,CAACR,EAAE,GAAG,CAACD,EAAE,GAAGQ,QAAQ,EAAEI,kBAAkB,MAAM,IAAI,IAAIX,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACY,IAAI,CAACb,EAAE,EAAEU,MAAM,EAAEC,MAAM,CAAC,EAAE;IAC5GJ,qBAAqB,GAAGtC,WAAW,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAACyC,MAAM,EAAEC,MAAM,CAAC,EAAE;MAC5DG,KAAK,EAAE;IACX,CAAC,CAAC;IACFvB,WAAW,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;EAC1B;EACA,MAAMwB,SAAS,GAAGP,QAAQ,CAAC;IACvB,GAAGT,OAAO;IACVzB,QAAQ;IACRV,SAAS,EAAE2B;EACf,CAAC,CAAC;EACF,SAASJ,MAAMA,CAAA,EAAG;IACdgB,WAAW,EAAE;IACb,IAAId,UAAU,KAAK,SAAS,EAAE;MAC1BZ,iBAAiB,GAAG0B,WAAW,GAAG,CAAC,KAAK,CAAC;MACzC9B,OAAO,GAAGG,cAAc,CAACH,OAAO,EAAE+B,gBAAgB,EAAEd,WAAW,EAAEb,iBAAiB,CAAC;IACvF,CAAC,MACI;MACDJ,OAAO,GAAGD,WAAW,CAACC,OAAO,EAAE+B,gBAAgB,EAAEd,WAAW,CAAC;MAC7D,IAAID,UAAU,KAAK,QAAQ,EACvB0B,SAAS,CAACC,UAAU,CAAC,CAAC;IAC9B;IACAV,UAAU,GAAG,KAAK;IAClBV,QAAQ,IAAIA,QAAQ,CAAC,CAAC;EAC1B;EACA,SAASqB,QAAQA,CAAA,EAAG;IAChBf,cAAc,CAAClB,IAAI,CAAC,CAAC;IACrBW,UAAU,IAAIA,UAAU,CAAC,CAAC;EAC9B;EACA,SAASf,MAAMA,CAACE,KAAK,EAAE;IACnB,IAAI,CAACL,iBAAiB,EAClBK,KAAK,GAAG,CAACA,KAAK;IAClBT,OAAO,IAAIS,KAAK;IAChB,IAAI,CAACwB,UAAU,EAAE;MACb,MAAMY,KAAK,GAAGH,SAAS,CAACI,IAAI,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEhD,OAAO,CAAC,CAAC;MAClDgC,MAAM,GAAGa,KAAK,CAACI,KAAK;MACpB,IAAIf,qBAAqB,EACrBF,MAAM,GAAGE,qBAAqB,CAACF,MAAM,CAAC;MAC1CC,UAAU,GAAG7B,iBAAiB,GAAGyC,KAAK,CAACK,IAAI,GAAGlD,OAAO,IAAI,CAAC;IAC9D;IACAwB,QAAQ,IAAIA,QAAQ,CAACQ,MAAM,CAAC;IAC5B,IAAIC,UAAU,EAAE;MACZ,IAAIH,WAAW,KAAK,CAAC,EAAE;QACnBC,gBAAgB,GACZA,gBAAgB,KAAKoB,SAAS,GAAGpB,gBAAgB,GAAG/B,OAAO;MACnE;MACA,IAAI8B,WAAW,GAAGf,SAAS,EAAE;QACzBV,qBAAqB,CAACL,OAAO,EAAE+B,gBAAgB,EAAEd,WAAW,EAAEb,iBAAiB,CAAC,IAAIU,MAAM,CAAC,CAAC;MAChG,CAAC,MACI;QACD8B,QAAQ,CAAC,CAAC;MACd;IACJ;EACJ;EACA,SAASQ,IAAIA,CAAA,EAAG;IACZhC,MAAM,IAAIA,MAAM,CAAC,CAAC;IAClBS,cAAc,GAAGhB,MAAM,CAACN,MAAM,CAAC;IAC/BsB,cAAc,CAACnB,KAAK,CAAC,CAAC;EAC1B;EACAS,QAAQ,IAAIiC,IAAI,CAAC,CAAC;EAClB,OAAO;IACHzC,IAAI,EAAEA,CAAA,KAAM;MACRU,MAAM,IAAIA,MAAM,CAAC,CAAC;MAClBQ,cAAc,CAAClB,IAAI,CAAC,CAAC;IACzB,CAAC;IACD0C,MAAM,EAAGC,CAAC,IAAK;MACX,OAAOZ,SAAS,CAACI,IAAI,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEM,CAAC,CAAC,CAAC;IACzC;EACJ,CAAC;AACL;AAEA,SAAS1C,OAAO,EAAEP,qBAAqB,EAAEN,WAAW,EAAEI,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}